/**
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Usage
 *
 * Add these <script> entries just after opening <head> tag (replacing braces and contents
 * (i.e. { placeholder }) with your values):
 * <script src='{ url to self hosted recaptcha.js }'></script>
 * <script>var recaptcha = new reCAPTCHA({ your site key/id });</script>
 *
 * Then use recaptcha.saveEvent anywhere else meaningful user interactions with your site occur.
 *
 * See comments below for details on how this library operates and how to best utilize it.
 */

(function() {
  /**
   * A wrapper library that helps to easily implement reCAPTCHA in the intended way.
   *
   * @param {string} siteKey The reCAPTCHA site key (also known as site ID).
   * @param {boolean} asyncDefer (Optional) Whether or not to load the reCAPCHA library asynchronous.
   *                             Default and recommendation is to not load async as this could
   *                             potentially limit overall data collected and thus the resulting
   *                             score may be less accurate.
   */
  window.reCAPTCHA = function(siteKey, asyncDefer=false) {
    var library = 'https://www.google.com/recaptcha/enterprise.js';
    var loading = false;
    var queue = [];

    _ensureLibraryLoaded().catch(function(err) {
      console.error('Failed to load reCAPTCHA library: ' + err);
    });

    /**
     * Generate a token and return it. All of these tokens can be safely ignored except
     * for the one you care to score. If you plan to score it and have provided a
     * backend URL to the constructor simply call scoreEvent for the thing you want to score.
     *
     * **When to Use:** Call this after meaningful user interactions with your site occur.
     *
     * **When Not to Use:** On page load due to limited data immediately after library loads.
     *
     * @param {string} action The name of the action to associate with the event (e.g. lead_form_submit).
     * @param {string} formSelector (Optional) If provided the token (generated by reCAPTCHA) and
     *                              action will be attached to this form as hidden form fields with
     *                              the names recaptcha_token and recaptcha_action (e.g '#lead_form').
     * @returns {Promise<string>} A promise that resolves with the reCAPTCHA token.
     */
    this.saveEvent = function(action, formSelector = null) {
      return new Promise(function(resolve, reject) {
        _getToken(action)
          .then(function(token) {
            if (formSelector) {
              _attachToForm(formSelector, token, action);
            }
            resolve(token);
          }).catch(function(err) {
            reject(err);
          });
      });
    };

    /**
     * Attaches the reCAPTCHA token and action to a form as hidden fields.
     *
     * @param {string} formSelector The selector of the form to attach the fields to.
     * @param {string} token The reCAPTCHA token to attach.
     * @param {string} action The reCAPTCHA action to attach.
     */
    function _attachToForm(formSelector, token, action) {
      var form = document.querySelector(formSelector);

      var hiddenTokenField = document.createElement('input');
      hiddenTokenField.type = 'hidden';
      hiddenTokenField.name = 'recaptcha_token';
      hiddenTokenField.value = token;
      form.appendChild(hiddenTokenField);

      var hiddenActionField = document.createElement('input');
      hiddenActionField.type = 'hidden';
      hiddenActionField.name = 'recaptcha_action';
      hiddenActionField.value = action;
      form.appendChild(hiddenActionField);
    }

    /**
     * Enqueues a promise to be resolved or rejected when the library is loaded.
     *
     * @param {function} resolve The function to call when the library is loaded.
     * @param {function} reject The function to call when the library fails to load.
     */
    function _enqueue(resolve, reject) {
      queue.push({resolve: resolve, reject: reject});
    }

    /**
     * Drains the queue of promises as resolved.
     */
    function _drainQueueAsResolved() {
      while (queue.length) {
        var promise = queue.shift();
        promise.resolve();
      }
    }

    /**
     * Drains the queue of promises as rejected.
     *
     * @param {Error} err The error to reject the promises with.
     */
    function _drainQueueAsRejected(err) {
      while (queue.length) {
        var promise = queue.shift();
        promise.reject(err);
      }
    }

    /**
     * Ensures the reCAPTCHA library is loaded.
     *
     * If loaded it resolves immediately, if currently loading it queues the action,
     * and if not loaded nor loading it loads the library and once complete drains
     * the queue if there is one.
     * @returns {Promise<string>} A promise that has different behavior depending on the state of
     *                            the reCAPTCHA library. If the library is loaded, the promise will
     *                            resolve immediately. If the library is loading, the promise queues
     *                            the action. If not loaded nor loading, the promise loads the library
     *                            and drains the queue (if there is one) when loading completes.
     */
    function _ensureLibraryLoaded() {
      return new Promise(function(resolve, reject) {
        if (typeof window.grecaptcha !== 'undefined') {
          resolve();
        } else if (loading) {
          _enqueue(resolve, reject);
        } else {
          loading = true;
          _enqueue(resolve, reject);

          var script = document.createElement('script');
          script.src = library + '?render=' + siteKey;
          script.async = asyncDefer;
          script.defer = asyncDefer;
          script.onload = function() {
            loading = false;
            _drainQueueAsResolved();
          };
          script.onerror = function(err) {
            loading = false;
            _drainQueueAsRejected(err);
          };
          document.head.appendChild(script);
        };
      });
    };

    /**
     * Gets a reCAPTCHA token for the given action.
     *
     * @param {string} action The action to score.
     * @return {Promise<string>} A promise that resolves with the reCAPTCHA token.
     */
    function _getToken(action) {
      return new Promise(function(resolve, reject) {
        _ensureLibraryLoaded()
          .then(function() {
            window.grecaptcha.enterprise.ready(function() {
              window.grecaptcha.enterprise.execute(siteKey, {action: action})
                .then(function(token) {
                  resolve(token);
                }).catch(function(err) {
                  reject(err);
                });
            });
          })
          .catch(function(err) {
            reject(err);
          });
      });
    };
  };
})();